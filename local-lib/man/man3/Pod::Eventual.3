.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Eventual 3"
.TH Pod::Eventual 3 "2009-11-29" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Eventual \- read a POD document as a series of trivial events
.SH "VERSION"
.IX Header "VERSION"
version 0.093330
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Your::Pod::Parser;
\&our $VERSION = \*(Aq0.093330\*(Aq;
\&
\&
\&  use base \*(AqPod::Eventual\*(Aq;
\&
\&  sub handle_event {
\&    my ($self, $event) = @_;
\&
\&    print Dumper($event);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1POD\s0 is a pretty simple format to write, but it can be a big pain to deal with
reading it and doing anything useful with it.  Most existing \s-1POD\s0 parsers care
about semantics, like whether a \f(CW\*(C`=item\*(C'\fR occurred after an \f(CW\*(C`=over\*(C'\fR but before
a \f(CW\*(C`back\*(C'\fR, figuring out how to link a \f(CW\*(C`L<>\*(C'\fR, and other things like
that.
.PP
Pod::Eventual is much less ambitious and much more stupid.  Fortunately, stupid
is often better.  (That's what I keep telling myself, anyway.)
.PP
Pod::Eventual reads line-based input and produces events describing each \s-1POD\s0
paragraph or directive it finds.  Once complete events are immediately passed
to the \f(CW\*(C`handle_event\*(C'\fR method.  This method should be implemented by
Pod::Eventual subclasses.  If it isn't, Pod::Eventual's own \f(CW\*(C`handle_event\*(C'\fR
will be called, and will raise an exception.
.SH "METHODS"
.IX Header "METHODS"
.SS "read_handle"
.IX Subsection "read_handle"
.Vb 1
\&  Pod::Eventual\->read_handle($io_handle, \e%arg);
.Ve
.PP
This method iterates through the lines of a handle, producing events and
calling the \f(CW\*(C`handle_event\*(C'\fR method.
.PP
The only valid argument in \f(CW%arg\fR (for now) is \f(CW\*(C`in_pod\*(C'\fR, which indicates
whether we should assume that we are parsing pod when we start parsing the
file.  By default, this is false.
.PP
This is useful to behave differently when reading a \fI.pm\fR or \fI.pod\fR file.
.SS "read_file"
.IX Subsection "read_file"
This behaves just like \f(CW\*(C`read_handle\*(C'\fR, but expects a filename rather than a
handle.
.SS "read_string"
.IX Subsection "read_string"
This behaves just like \f(CW\*(C`read_handle\*(C'\fR, but expects a string containing \s-1POD\s0
rather than a handle.
.SS "handle_event"
.IX Subsection "handle_event"
This method is called each time Pod::Evental finishes scanning for a new \s-1POD\s0
event.  It must be implemented by a subclass or it will raise an exception.
.SS "handle_nonpod"
.IX Subsection "handle_nonpod"
This method is called each time a non-POD segment is seen \*(-- that is, lines
after \f(CW\*(C`=cut\*(C'\fR and before another command.
.PP
If unimplemented by a subclass, it does nothing by default.
.SS "handle_blank"
.IX Subsection "handle_blank"
This method is called at the end of a sequence of one or more blank lines.
.PP
If unimplemented by a subclass, it does nothing by default.
.SH "EVENTS"
.IX Header "EVENTS"
There are four kinds of events that Pod::Eventual will produce.  All are
represented as hash references.
.SS "Command Events"
.IX Subsection "Command Events"
These events represent commands \*(-- those things that start with an equals sign
in the first column.  Here are some examples of \s-1POD\s0 and the event that would be
produced.
.PP
A simple header:
.PP
.Vb 1
\&  =head1 NAME
\&
\&  { type => \*(Aqcommand\*(Aq, command => \*(Aqhead1\*(Aq, content => "NAME\en", start_line => 4 }
.Ve
.PP
Notice that the content includes the trailing newline.  That's to maintain
similarity with this possibly-surprising case:
.PP
.Vb 2
\&  =for HTML
\&  We\*(Aqre actually still in the command event, here.
\&
\&  {
\&    type    => \*(Aqcommand\*(Aq,
\&    command => \*(Aqfor\*(Aq,
\&    content => "HTML\enWe\*(Aqre actually still in the command event, here.\en",
\&    start_line => 8,
\&  }
.Ve
.PP
Pod::Eventual does not care what the command is.  It doesn't keep track of what
it's seen or whether you've used a command that isn't defined.  The only
special case is \f(CW\*(C`=cut\*(C'\fR, which is never more than one line.
.PP
.Vb 2
\&  =cut
\&  We are no longer parsing POD when this line is read.
\&
\&  {
\&    type    => \*(Aqcommand\*(Aq,
\&    command => \*(Aqcut\*(Aq,
\&    content => "\en",
\&    start_line => 15,
\&  }
.Ve
.PP
Waiving this special case may be an option in the future.
.SS "Text Events"
.IX Subsection "Text Events"
A text event is just a paragraph of text, beginning after one or more empty
lines and running until the next empty line (or \fI=cut\fR).  In Perl 5's standard
usage of Pod, text content that begins with whitespace is a \*(L"verbatim\*(R"
paragraph, and text content that begins with non-whitespace is an \*(L"ordinary\*(R"
paragraph.
.PP
Pod::Eventual doesn't care.
.PP
Text events look like this:
.PP
.Vb 5
\&  {
\&    type    => \*(Aqtext\*(Aq,
\&    content => "a string of text ending with a\en",
\&    start_line =>  16,
\&  }
.Ve
.SS "Blank events"
.IX Subsection "Blank events"
These events represent blank lines (or many blank lines) within a Pod section.
.PP
Blank events look like this:
.PP
.Vb 5
\&  {
\&    type    => \*(Aqblank\*(Aq,
\&    content => "\en\en\en\en",
\&    start_line => 21,
\&  }
.Ve
.SS "Non-Pod events"
.IX Subsection "Non-Pod events"
These events represent non-Pod segments of the input.
.PP
Non-Pod events look like this:
.PP
.Vb 5
\&  {
\&    type    => \*(Aqnonpod\*(Aq,
\&    content => "#!/usr/bin/perl\enuse strict;\en\enuse Acme::ProgressBar\en\en",
\&    start_line => 1,
\&  }
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\&  Ricardo SIGNES <rjbs@cpan.org>
.Ve
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2009 by Ricardo \s-1SIGNES\s0.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

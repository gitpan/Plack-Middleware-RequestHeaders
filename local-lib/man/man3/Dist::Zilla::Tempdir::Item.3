.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Dist::Zilla::Tempdir::Item 3"
.TH Dist::Zilla::Tempdir::Item 3 "2012-05-26" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dist::Zilla::Tempdir::Item \- A result object for things that DO() DZ::R::Tempdir;
.SH "VERSION"
.IX Header "VERSION"
version 0.01053721
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  my $foo = Dist::Zilla::Tempdir::Item\->new(
\&    name => \*(AqPath/To/File.txt\*(Aq,
\&    file => $dzilfile,
\&  );
\&  $foo\->set_new;
\&  $foo\->is_new; # true
\&  $foo\->is_deleted; # false
\&  $foo\->set_deleted;
\&  $foo\->is_new; # false
\&  $foo\->is_deleted; # true.
.Ve
.PP
Ultimately, I figured using a character with "\f(CW\*(C`eq\*(C'\fR" every where in extending code
was a way to extra bugs that were hard to detect. Going via all the Object-Oriented niceness
you'll probably incur* a small performance penalty,  but things going \fBBang\fR when you
make a typo or add invisible white-space is a Good Thing.
.PP
* albeit immeasurably insignificant in size, especially for something that will only take
15 seconds of run-time every once in a while, not to mention the overhead is drowned by the
fact we're doing file-system \s-1IO\s0 and running many of the files through a complete hashing
algorithm to test for modification.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "status"
.IX Subsection "status"
.Vb 2
\&  isa => Str,
\&  is  => rw,
.Ve
.PP
The internal status character. You can mangle this yourself if you want, and for compatibility with older versions
of this dist, you may even have to, but try not to, if it breaks, something something something pieces.
.PP
Using the is_* and set_* accessors is a \fImuch\fR smarter idea.
.PP
At present, the characters M, O, N and D have defined meanings, but this could change. ( Its not even unforeseeable expanding it to
be 2 characters to represent different parts of state, I probably will not do that, but do not pretend I will not ;] )
.SS "file"
.IX Subsection "file"
.Vb 3
\&  isa      => Dist::Zilla::Role::File,
\&  required => 1,
\&  is       => rw
.Ve
.PP
This is the Dist::Zilla::File::* item which we refer to. For items that \f(CW\*(C`is_deleted\*(C'\fR, \f(CW\*(C`file\*(C'\fR is likely to be the file before it got deleted.
.PP
For \f(CW\*(C`is_new\*(C'\fR and \f(CW\*(C`is_original\*(C'\fR files, the item is the file itself, and for \f(CW\*(C`is_modified\*(C'\fR, its the modified version of the file.
.SS "name"
.IX Subsection "name"
.Vb 3
\&  isa      => Str,
\&  required => 1,
\&  is       => rw,
.Ve
.PP
This is the path to the file relative to the dist root.
.SH "METHODS"
.IX Header "METHODS"
.SS "is_modified"
.IX Subsection "is_modified"
returns if the file is modified or not.
.SS "set_modified"
.IX Subsection "set_modified"
sets the state to 'modified'
.SS "is_original"
.IX Subsection "is_original"
returns if the file is the original file or not.
.SS "set_original"
.IX Subsection "set_original"
sets the state to 'original'
.SS "is_new"
.IX Subsection "is_new"
returns if the file is new or not ( that is, if it wasn't in the dist prior to executing
the given code ).
.SS "set_new"
.IX Subsection "set_new"
sets the state to 'new'
.SS "is_deleted"
.IX Subsection "is_deleted"
returns if the file is deleted or not ( that is, if it were deleted during the execution phase )
.SS "set_deleted"
.IX Subsection "set_deleted"
sets the state to 'deleted'
.SH "AUTHOR"
.IX Header "AUTHOR"
Kent Fredric <kentnl@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Kent Fredric.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
